+++
title = "Automatic Programming: Iteration 4"
description = "From looms to LLMs — Grace Hopper dreamed of programs writing themselves, and each generation of programmers has resisted the next layer of abstraction."
template = "page.html"
weight = 0
draft = false
date = 2026-02-08
updated = 2026-02-08
[extra]
desc = "From looms to LLMs — Grace Hopper dreamed of programs writing themselves, and each generation of programmers has resisted the next layer of abstraction."
keywords = "automatic programming, Grace Hopper, COBOL, LLM, code generation, compilers, abstraction"
discussion_number = 50
discussion_url = "https://github.com/orgs/developmeh/discussions/50"
+++

<img src="/devex/mark1-computer.jpg" alt="Grace Hopper: Mark 1 Computer" style="width: 100%; height: 600px; object-fit: cover; object-position: center calc(50% + 50px);">

## Automatic Programming: Iteration 4

While I know that the discourse is not complete binary whether you are for or against LLM generated code it's probably the right time to take a step back a few years and explore the iterations of our industry.

Let's just work backwards, COBOL, iteration 3.

> [Common Business-Oriented Language] (Synonymous with evil.) A weak, verbose, and flabby language used by code grinders to do boring mindless things on dinosaur mainframes. Hackers believe that all COBOL programmers are suits or code grinders, and no self-respecting hacker will ever admit to having learned the language. Its very name is seldom uttered without ritual expressions of disgust or horror.
> _Evans, Claire L - Broad band_ the untold story of the women who made the Internet_ -> _From The Hacker's Dictionary_

Yes, the perpetual software of big finance and numerous other systems. While I haven't written COBOL myself I have had to rewrite at least one system written in COBOL.

Poking fun aside COBOL exists because of the dream that non-experts could be computer programmers. By today's standards you still need to be an expert to write COBOL. Prior to its creation, software was written in assembly and before that machine code, and before that patch cables, actual wires, iteration 1.

> Grace knew that would only happen when two things occurred:
> 1. Users could command their own computers in natural language.
> 2. That language was machine independent.
> That is to say, when a piece of software could be understood by a programmer as well as by its users, when the same piece of software could run on a UNIVAC as easily as on an IBM machine, code could begin to bend to the wills of the world. Grace called this general idea "automatic programming"...
> _Evans, Claire L - Broad band_ the untold story of the women who made the Internet_

That Grace of course was Grace Hopper, and she was obsessed with making programming easier and more efficient. In her time programming was a kind of wizardry and very few knew the incantations to make the computer operate. From a business standpoint making programming easier was bad for business since computer companies sold the computer and the software.

Portable programs, ones that could be written on any machine for any other machine was a business risk. It created competition so there was resistance.

> Those who resisted automatic programming became known as "Neanderthals." They might as well have called themselves framebreakers, as Lord Byron had over a century before.
> _Evans, Claire L - Broad band_ the untold story of the women who made the Internet_

"Framebreakers" refers to those workers who opposed the automatic loom, better known as the Luddites.

Before computers cloth was made on the loom and the origin of the punchcard was used to create an automatic loom. After its invention there was not much use for using a manual loom. It was disruptive and changed an entire industry, displacing workers.

Grace and her cadre believed in a future where the programs write themselves. There is some corollary to today with code generation, which actually is programs writing themselves, something Grace dreamed of. The difference between the loom and the compiler is only in the growth potential. Cloth was an end result of a chain of optimization but while you could tirelessly create it in any pattern imaginable, someone still needed to imagine the patterns. Variety of cloth became commonplace, the art remained, the drudgery was lost.

Now I respect that for some the act was the value, I share those feelings. I love writing the actual code, I care about it more than the product it produces. An opinion whose popularity depends on what side of the invoice you sit.

> A quick lesson: computers do not understand English, French, Mandarin Chinese, or any human language. Only Machine code, usually binary, can command a computer, at its most elemental level, to pulse electricity through its interconnected logic gates.
> _Evans, Claire L - Broad band_ the untold story of the women who made the Internet_

Programs are essentially the aggregation of basic operations, layers upon layers. If we think of code generation as just another kind of compiler it's part of a long lifeline of change approaching the ideal "automatic programming."

Of course I would prefer to ask Grace her formal opinion. But in her time when presenting her arguments, mathematicians were once inundated in the tedium of arithmetic to solve their equations. Computers arrived and essentially removed the need for those steps and allowed them to get closer to the interesting part, the solutions. She argued that the compiler did the same thing, modulating the complexity of using computers allowed programmers to spend more time on stimulating thoughts.

Of course the reality was mathematicians became programmers to advance their work.

Programmers used compilers to build elegant languages, and COBOL.

I think it's quite funny to have the perspective that programs are binary, iteration 2, and writing the program for the computer was to create something that could accurately generate binary programs.

Now we stand at another transition where automatic programming is telling the computer to write the code that the compiler turns into a binary program. If the compiler was the 3rd level operation we are now at the 4th.

## Here is where it all came together though:

> Grace loved coding, but she admitted that "the novelty of inventing programs wears off and degenerates into the dull labor of writing and checking programs. This duty now looms as an imposition on the human brain"
> _Evans, Claire L - Broad band_ the untold story of the women who made the Internet_

I have been feeling this for years, the code just keeps getting more repetitive. I just keep doing the same extremely complicated and extremely boring operations over and over again. The novelty of software I grew up with in the 2000s is over. Everything is a framework or a dogma and all solutions are solving the same problems with a different color scheme and font.

If anything would make me embrace the 4th level it's this, even if it means no one needs me anymore. I can at least see the realization of Grace's dream and in some way if everyone becomes a programmer finally, I'll have more people to talk to about what I love.

We aren't there yet, the software world is still pretty complicated and you have to know a lot of special dance moves to get things working right. But it's not going to be forever.

## The book

Before I wander off into a diatribe of where our future is going lemme just stop and tell you to read this book:

[Broad Band - Claire L. Evans](https://www.penguinrandomhouse.com/books/545427/broad-band-by-claire-l-evans/)

It's a good one, it has changed my mind on if I will continue to call myself an engineer or a programmer. The definition has finally been clarified. I was today - 2 weeks old and that was too long to know the truth.

Also it answers the question of why women were not present in Computer Science but I was taught by women who had careers in computer science.

Point is strong recommendation.

## Where are we going?

I dunno, maybe we are all out of work. Maybe our MBA Degree bosses will finally see their reality of the numbers going up and to the right forever.

I see it like this, programming ended when the job absorbed all its roles by mere definition. It has been an amalgam for a while and that has been a crime. Now I can focus on building things again at the scale required in our times. I can concurrently build 2 or 3 projects while focusing on my writing. Sounds like a dream and the troubles of today are not forever.

The current goals of centralized AI is unsustainable and within a few years the ASICs will arrive, our computers will be packed with high bandwidth memory and the models will be local. Just like how all of a sudden we all started walking around super computers in our pockets we will build the infrastructure to build all the hardware we need to move forward.

I mean we live in the dumbest timeline and greed seems to be winning but if the pattern from past is here to loop again we go from the dumb time to the bright time for a while again. I am looking forward to that at least.
